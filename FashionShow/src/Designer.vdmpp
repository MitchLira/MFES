class Designer
	types
	instance variables
		public name: FashionShow`String;
		public models: set of Model;
		public items: set of Item;
	values
	operations
	 	public Designer: FashionShow`String ==> Designer 
		Designer(n) == 
		(
			name := n;
			models := {};
			items := {};
			return self;
		);
		public getName: () ==> FashionShow`String
			getName() == return name
			pre name <> ""
			post RESULT = name;
		
		public getModels: () ==> set of Model
			getModels() == return models
			pre models <> {}
			post RESULT = models;
			
		public getItems: () ==> set of Item
			getItems() == return items
			pre items <> {}
			post RESULT = items;
	 
	 public itemAlreadyAdded : Item ==> bool
	 	itemAlreadyAdded(item) == (
	 		if(item in set items) then 
	 			return true
	 		else 
	 			return false;
	 	);
	
	 public addModel: Model ==> ()
	 	addModel(model) == (
	 	if (not modelAlreadyInShow(model)) then 
	 		models := models union {model}
	 )
	 pre model not in set models;
	 
	 public addModels: set of Model ==> ()
	 	addModels(newModels) == (
	  for all m in set newModels do (
	 		if (not modelAlreadyInShow(m)) then
	 			models := models union {m};
	 		)
	 	)
	 	pre not (newModels subset models);
	 	 
	 public remModel: Model ==> ()
	  remModel(model) == (
	  	if (modelAlreadyInShow(model)) then
	  		models := models \ {model}
	 )
	 pre model in set models;
	 
	 public remModels: set of Model ==> ()
	  remModels(oldModels) == (
	   for all model in set oldModels do (
	    if(modelAlreadyInShow(model)) then
	  		models := models \ {model};
	  	)
	 )
	 pre oldModels subset models;
	 
	 public modelAlreadyInShow : Model ==> bool
			modelAlreadyInShow(model) == (
				if (model in set models) then
					return true
				else 
				  return false;
	 );
	  	
	 public addItem: Item ==> ()
	  addItem(item) == (
	  if(not itemAlreadyAdded(item)) then
	  	items := items union {item}
	 )
	 pre not (item in set items);
	 
	 public addItems: set of Item ==> ()
	 	addItems(newItems) == (
	 	for all i in set newItems do (
	 		if (not itemAlreadyAdded(i)) then
	 			items := items union {i};
	 		)
	 )
	 pre not (newItems subset items);
	 		
	 public remItem: Item ==> ()
	  remItem(item) ==
	   if(itemAlreadyAdded(item)) then
	   	items := items \ {item}
	 pre item in set items;
	 
	 public remItems: set of Item ==> ()
	 	remItems(oldItems) ==
	 		for all i in set oldItems do (
	 			if(itemAlreadyAdded(i)) then
	 				items := items \ {i}
	 		)
	 pre oldItems subset items;
	 
	functions
	
	traces
	-- TODO Define Combinatorial Test Traces here
end Designer

